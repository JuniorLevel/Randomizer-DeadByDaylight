Одно из свойств ООП является абстракция
Абстракция - это процесс моделирования сущности. Анализ сущности.
Выявление нужных параметров сущности, которые потом станут (свойствами, методами).
Абстрагироваться - отделиться. Избавить сущность от других ненужных нам параметров
ООП начинается с построения абстракции(модели, сущности)
Второе из свойств ООП является наследование
Наследоваться - означает расширить сущность
Наследование позволяет расширить и повторно использовать код
Третье из свойств ООП является Полиморфизм
Пример: когда есть один и тот же метод под одним и тем же именем, который будет меняться в зависимости от сущности. Эти методы могут содержать разные данные и действия, но результат будет один
Четвертое свойство ООП является Инкапсуляция
Инкапсуляция - это скрытие каких-то реализаций
Некоторые свойства можно обозначать, как недоступные извне
Скрыть - означает нельзя обратиться и получить сырые данные. Реализация видна.
Прототип в JS. Основой ООП в JS является прототипное программирование.
Прототипом может выступать лишь объект

a -> b -> c
Синтаксический сахар - это более удобные способы обращения и манипуляции сущностями в JS.
с начала ES2015 появился class
class -> function
ab class -> class -> object
Класс - модель, абстракция, которая описывает сущность
ООП - красиво делить на модули
Конструктор используется для того, чтобы установить свойства объекта, когда мы его создаём на основе класса
Конструктор вызывается в момент создания объекта
Урок 4 ООП
// this в JavaScript
// по умолчанию this указывает на window
// стрелочная функция -> this -> window
// this в классе будет указан на экземпляр, который будет создан через new на основе класса
// Метод call() - позволяет вызвать функцию с тыканьем в морду контекста
// Метод call() вызвал функцию и сказал, что this будет b1
// Метод apply() передаёт аргументы массивом, а не списком
// Минус - выполняется функция сразу, this будет на момент вызова функции
// bind()

Деструктуризация в JavaScript

// Rest ... Когда говорят о REST - все добавляют слово параметры или аргументы. Основные приминения rest:

// Применение синтаксиса rest в аргументах функции для того, чтобы
// можно было использовать много аргументов

// rest применяется лишь для аргументов функции
// чтобы их засунуть в один массив(псевдомассив)
// не теряются аргументы

// spread ... разбитие одну переменную, строку, объект, массив на несколько. Его применяют для создания поверхностной копии массива.
// Если есть вложение, то быть осторожным. Когда о spread говорят
// 'spread синтаксис'.

// React

Свойства(props) и состояние(state)

-   Свойства компоненту передаются от родительского компонента
-   Свойства нельзя передавать родительскому компоненту
-   Свойства можно передавать только от родительского компонента дочернему и никак иначе!
-   Компонент не должен изменять собственные свойства
-   Компонент может изменять собственное состояние
-   Компнент не может изменять состояние других компонентов
-   Можно влиять на изменение состояния других компонентов
    Компонент ниже по иерархии может отправить запрос на изменение состояния вышестоящему компоненту
    Итог:
    У каждого компонента есть свойства, переданные родителем
    Изменять свойства не рекомендуется.
    Можно передавать часть своих свойств и состояния дочерним компонентам в виде свойств
    Компонент подлежит ререндерингу при изменении свойств или состояния

React hooks в версии 16.8
Раньше можно было управлять состоянием лишь в классовых компонентах,
а функциональные компоненты использовались лишь для stateless компонентов.
Позволяют управлять состоянием в функциональных компонентах
useState и useEffect - основные хуки
